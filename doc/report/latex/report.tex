\documentclass[english, 11pt, titlepage]{article}

\usepackage[utf8]{inputenc}    
\usepackage[english]{babel}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{appendix}

%Path relative to the .tex file containing the \includegraphics command
\usepackage{graphicx}
\graphicspath{ {images/} }

\pagestyle{fancy}
\fancyhf{}
\rhead{(\thepage)}
\lhead{LP2A - Spring 2021}

% Clickable table of contents
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

% Code + colors
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

    \include{titlepage.tex}

    \pagebreak
    \tableofcontents

    \pagebreak
    \section{Introduction}
    \subsection{Project Analysis}
    % Talk about UML, OOP programming
    First of all, we performed an analysis of the subject by defining, the behaviour, the constraints or even the signature of each class and represented all of this in an \textbf{UML Class Diagram}.
    \subsection{Organization}
    % Talk about task repartition, package organization, documentation
    \subsubsection{Tools used}
    % Talk about git, IntelliJ
    We also used some tools like IntelliJ Idea as IDE, for time saving tasks like compiling, creating packages, making unit tests, and so on. As a \textbf{Version Control System (VCS)}, we used \emph{Git}. It allowed us a better collaboration, a way to backup our files and, last but not least : It is a tool widely spread in the computer science jobs. So performing on this tool is a real benefit for the future.
    \begin{center}
        \includegraphics[width=2cm]{IntelliJ_IDEA_Icon.svg.png}
        \hspace{2cm}
        \includegraphics[width=2cm]{git.png}
    \end{center}

    Moreover, we decided to write this report in latex, as it is easier to insert some code, and mathematical formulas.
    \subsubsection{Documentation of the source files}
    As we used IntelliJ Idea, documenting the code was really simple. We trigger the snippet by typing \verb|/**|, then by pressing \verb|<Tab>| and it generates the documentation template, all we need to do is to fill in the description of the parameters and the return, and to provide a description of the function.

    \begin{lstlisting}
        // Example of documentation generation
        /**
        * PUT DESCRIPTION HERE
        * @param position PUT PARAMETER DESCRIPTION HERE
        * @return PUT RETURN DESCRIPTION HERE
        */
    \end{lstlisting}

    \section{The game components}
    This project is split into two main components : \emph{game engines} and \emph{graphical user interface (GUI)}. The engines are the core of the game. They ensure IAs are following certain rules, as well as player, who are restricted in their choices with the GUI by displaying only "rules friendly" moves. We will detail some of the functionnalities.

    Before explaining the engines, we need to talk about the components needed for it. They play a main role in the OOP. Yet, they are quite simple. For a summarized view of the structure, see APPENDIX X

    \subsection{The Players}
    The players are the entities playing the game. They have several actions such as moving a Piece, throw a dice, or pass. However, they are two types of player : real players (Humans) and Bots (Artificial Intelligence), their actions would be different, for instance when moving a piece. By following OOP principles, all the player types inherit from an abstract parent class called \verb|Player|. 
    \subsubsection{Humans}
    Humans are described in the child class \verb|Human|. The difference between them and AIs results in the actions with the board, such as throwing a dice, choosing the piece to move, as there is some GUI implemented in the class. Here is the code for the \verb|choosePiece| method :
    \begin{lstlisting}
    // Human.java
    public Piece choosePiece() {
        List<Piece> movablePiece = this.getMovablePieces();
        if (movablePiece.size() == 0) {
            JOptionPane.showMessageDialog(null, this.getName() + " : You can't move any piece, you have to pass");
            return null;
        } else {
            movablePiece.sort(new SortByBestMove());
            Collections.reverse(movablePiece);
            String[] stringMovablePiece = new String[movablePiece.size() + 1];

            for (int i = 0; i < movablePiece.size(); i++) {
                stringMovablePiece[i] = "" + movablePiece.get(i).getNumber();

            }
            stringMovablePiece[movablePiece.size()] = "pass";
            String result = (String) JOptionPane.showInputDialog(null, this.getName() + " : Choose the piece that you want move " + this.getDice().getValue() + " cases forward", this.getName() + " : Choose Piece", JOptionPane.QUESTION_MESSAGE, null, stringMovablePiece, stringMovablePiece[0]);

            if (result == null) {
                System.exit(1);
            }

            int intResult;
            try {
                intResult = Integer.parseInt(result);
            } catch (NumberFormatException e) {
                return null;
            }
            return this.getPieces()[intResult - 1];
        }
    }
    \end{lstlisting}
    We can see that there is some GUI code inside the \verb|Human| class. We found it was a good compromise between code organization and code efficiency.

    \subsubsection{Artificial Intelligences}
    Artificial Intelligences (AIs) work slightly different : there is no GUI code, as they are managed by the computer. So the work here was to implement the reflexion of the AI. As the main goal of this project was not to do machine learning, we simply implement a procedural set of \verb|if/else| statements in a separate java class:
    \begin{lstlisting}
    // SortByBestMove.java
    public class SortByBestMove implements Comparator<Piece> {
        @Override
        public int compare(Piece piece1, Piece piece2) {
            if (piece1 == null) {
                return -1;
            } else if (piece2 == null) {
                return 1;
            } else if (piece2.isAtStable() && !piece1.isAtStable()) {
                return -1;
            } else if (piece1.isAtStable() && !piece2.isAtStable()) {
                return 1;
            } else if (!piece1.isAtImmuneSquare() && piece2.isAtImmuneSquare()) {
                return 1;
            } else if (!piece2.isAtImmuneSquare() && piece1.isAtImmuneSquare()) {
                return -1;
            } else {
                return piece1.getPosition().getProgress() - piece2.getPosition().getProgress();
            }
        }
    }
    \end{lstlisting}

    \subsection{The Coordinates System}
    Each position object is composed of a color which is the color of the player and an integer "progress" which is the number of squares covered from the starting square. In the PositionConstant class, we make the link between the name of the important squares and the value of progress to which they correspond. Thus the stable is worth -1, the departure 0 and the arrival or Home is worth 57. Thanks to this system, the progression of each player on the game board is easy to manage, because it is enough to increment the number of squares you want to advance. But the problem arises when you want to compare the positions of the pieces of the other players, because each position is given in a base relative to each player represented by the color of this player. To do this we need to create a function that allows to convert a position from one color to another. To do this, using modular arithmetic and basic operations, we calculate the position in the new base (See \autoref{section:translating_coordinates}). Once this value has been calculated, the method creates a new Position object with this calculated value and the desired color.
    \subsection{The board}
    The board of the game is quite simple. It contains all the players (no matter which type they are), and a Dice. Its complexity only results in its constructor, which is depending of the gamemode (See \autoref{section:gamemodes}). The \verb|Board| class contains some methods, such as \verb|getPiecesAtCoordinates| :
    \begin{lstlisting}
        /**
        * Computes the pieces at given coordinates
        * @param position the position to check
        * @return List of piece if found, null either
        */
       public List<Piece> getPiecesAtCoordinates(Position position){
           List<Piece> result = new ArrayList<>();
           for (Player player : getPlayers()) {
               for (Piece piece : player.getPieces()) {
                   if (piece.getPosition().equals(position)) {
                       result.add(piece);
                   }
               }
           }
           if (result.isEmpty()) {
               return null;
           } else {
               return result;
           }
       }   
    \end{lstlisting}
    \subsubsection{The pieces \& the dice}
    Pieces and Dice are both objects, they contain several methods such as moving a piece, throw the dice, etc\dots. We decided to use pictures for the pieces, with a number and the four colors.

    \begin{center}
        \includegraphics[width=2cm]{pieceBlue1.png}
        \hspace{2cm}
        \includegraphics[width=2cm]{pieceGreen2.png}
    \end{center}

    \section{The game engines}
    They are 3 engines in total. Each engine is called depending of the gamemode. By following OOP principles, all the engines inherit from an abstract parent class called \verb|Engine|.
    \subsection{Managing collisions}
    Managing collisions is a central feature of the game, it ensure pieces go to the stable according to the rules of the game (and according to the \autoref{app:algorithm})
    
    This feature is required by the rules of the game, we implemented it, but with more time, we could have tested it. We might expect some bugs.
    % Implemented, but not tested

    \subsection{Gamemodes}
    \label{section:gamemodes}
    In this game, there is various gamemodes, designed for a certain number of playstyles. You can select it at the beginning of the game.

    \begin{center}
        \includegraphics{gamemodeSelection.png}
    \end{center}

    The gamemode selected displays at the status bar of the windows. With theses modes, player can play alone, with four player on the same computer, or watch AIs play (4 AIs gamemode is best for test purposes).

    \subsubsection{1 Player versus 3 Artificial Intelligences}
    This is one of the main gamemode, where one player plays against 3 AIs.

    \subsubsection{4 Players}
    This gamemode unlieve the entire potential of the GUI, by allowing four players to play in the same time on the same computer. Each player plays one after the other.

    \subsubsection{4 Artificial Intelligences}
    This gamemode was not required in the specifications, but we made it for \emph{experimental purposes}. It allowed us to check if everything was working properly without having a GUI. The four players are AIs and are playing by following the rules.
    
    \subsubsection{Debug}
    The debug gamemode is only made for \emph{test purposes}. It moves all the pieces square by square.

    \section{The graphical user interface (GUI)}

    In order to create the graphical user interface, we use the framework swing. We choose this one and not another one for different reason, first it is very easy to learn and flexible to use for a small project. Moreover, there is a lot of tutorial about it on internet, and it has been very useful for us to learn fast and to on time.


    \subsection{Aspect of the game}

    %plateau de jeu

    This is our GUI. To do that we use a class Gamegui that extend JFrame who create the window of our game and set is behaviour. Inside this we add an object of gameBoardGui who extend JPanel. This second class create the image of the game board. This image is just a picture of a game board that we found on the internet, and we paint in front of it the name of the player and the piece on the right place.



    \subsection{Interactions with the user}

    For the interaction with the user we choose to not use a button or selection on the same window that contains the  game board. Instead of that we prefer to use a pop-up window given by the class JOptionPane. In this new window the user can choose the piece that he want to move or click on a button to throw the dice or just read the message sending to him by the game. At the beginning of the party to let the player choose the game mode and the pseudo of the player. At the end we suggest to the player to continue playing by the same way. In the window that ask the user to choose the piece that he want to move, we just show him the piece that he is able to move according to the rules. Moreover, the piece on list are sorted by the best move in first so if the user just press ENTER it will play the best move directly.
    %tout les type de popup

    \subsection{Translating relatives coordinates in absolute coordinates}

    One of the biggest problem with our coordinate system is the difficulty to know the position where we have to print each piece on the screen. To solve this problem we create the class CaseMapping, who contain a big array that make the like between the relative position and the absolute position. To generate this array we can’t use a mathematic formula because the sequence of the case on the board is not linear or logical. So we do it case by case, and we can group the different straight line.  From one player to another the mapping is the same, but we just have to turn the board for 90°. So to avoid long copy and paste is used trigonometric formula to do this computation. Where i is the number of the player and X and Y the initial coordinate common to all the player.

    rotatedX = cos(i*90)*X + sin(i*90)*Y
    rotatedY = sin(i*90)*X + cos(i*90)*Y


    \section{Conclusion}
    \subsection{Improvements paths}
    \subsection{Benefits of this project}

    The time to complete the project was very short so if we get more time we should be able to do more feature. About the Gui there is a lot of things to improve, first if two pieces are on the same case on the board the piece that arrived the last is totally hide by the other piece that is on top, we should manage it to be able to see the two piece in the same time. Second we don’t use multi threading to separate the GUI and the engine so if  one of them crash the whole application is down. Third we don’t use double buffering when we paint the piece on the board. So when the piece position is updating, the user can see a short moment where the pieces and the pseudo disappear and reappears. And if there is a lot of updating in the same time it is very ugly for the user. Finally, there is in the code a lot of optimization that we can do to save more memory or run the programme faster, one of them is to avoid the use of the pop-up window who use a lot of resources each time the window is created.

    \label{section:translating_coordinates}

    \pagebreak
    \appendix
    \appendixpage
    \addappheadtotoc
    \section{Unified Modeling (UML) Diagram}
    \subsection{Engine}

    \pagebreak
    \section{Simplified algorithm}
    \label{app:algorithm}
    This figure explains the reflexion behind the colision detection method in the \verb|Engine|.
    \begin{figure}[h]
        \centering
        \vspace{0.3cm}
        \includegraphics{Logigram.png}
    \end{figure}
    
\end{document}